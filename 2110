전체 프로젝트 공유 : https://bit.ly/2ZaI9sJ

 0. 학번 : 2110

 [프로젝트 1 : 태양계 구현]
1)연구소 이름 : (고기만두연구소)
2)연구소가 해결하려는 문제 : (처음으로 태양계를 배운 초등학교 2학년의 고기만두양의 태양계의 모습에 대한 궁금증 해결)
3)연구소의 깃헙 링크 : (https://github.com/bborish/BBORISH)
4)내가 기여한 내용
(from visual import *
from visual.graph import *

scene = display (title = 'Planets Orbiting the Sun', width = 800, height = 800, range = vec(25000, 25000, 25000), center = vec(1000, 0, 0))
scene.autoscale = True 

sun = sphere (pos=vec(0,0,0), radius = 100, texture = textures.stucco, color = color.yellow, mass = 10)
# 태양의 반지름, 색깔, 질량, 위치 등을 설정
mercury = sphere (pos = vec(200,0,0), radius = 50, texture = textures.wood, color = color.red)
# 수성의 반지름, 색깔, 질량, 위치 등을 설정
mercury.trail = curve(color = mercury.color)
mercury.velocity = vector(0,0,295)
#수성의 속도 설정

venus = sphere (pos = vec(373.664,0,0), radius = 50, texture = textures.wood, color = color.orange)
#금성의 반지름, 색깔, 질량, 위치 등을 설정
venus.trail = curve(color = venus.color)
venus.velocity = vector(0,0,225)
#금성의 속도 설정

earth = sphere (pos = vec(516.664,0,0), radius = 50, texture = textures.earth, mass=2)
#지구의 반지름, 색깔, 질량, 위치 등을 설정
earth.trail = curve(color = color.yellow)
earth.velocity = vector(0,0,195)
#지구의 속도 설정

moon = sphere (pos=vec(516.664+5.0016, 0,0), radius = 10, color=color.white)
#달의 반지름, 색깔, 질량, 위치 등을 설정
moon.trail = curve (color = moon.color)
moon.velocitylocal = vector(0,0,195+1)


mars = sphere(pos= vec(787.222,0,0), radius = 50, texture= textures.wood, color = color.green)
#화성의 반지름, 색깔, 질량, 위치 등을 설정
mars.trail = curve(color=mars.color)
mars.velocity = vector(0,0,155)
#화성의 속도 설정

jupiter = sphere (pos = vec(2688.068,0,0), radius = 75, texture = textures.gravel, color = color.cyan)
#목성의 반지름, 색깔, 질량, 위치 등을 설정
jupiter.trail = curve(color = jupiter.color)
jupiter.velocity = vector(0,0,70)
목성의 속도 설정

saturn = sphere (pos = vec(4920.048,0,0), radius = 75, texture = textures.gravel, color = color.blue)
#토성의 반지름, 색깔, 질량, 위치 등을 설정
saturn.trail = curve(color = saturn.color)
saturn.velocity = vector(0,0,50)
#토성의 속도 설정

uranus = sphere (pos = vec(9924.19,0,0), radius = 75, texture = textures.wood, color = color.magenta)
#천왕성의 반지름, 색깔, 질량, 위치 등을 설정
uranus.trail = curve(color = uranus.color)
uranus.velocity = vector(0,0,30)
#천왕성의 속도 설정

neptune = sphere (pos = vec(15544.811,0,0), radius = 75, texture = textures.wood, color = color.red)
#해왕성의 반지름, 색깔, 질량, 위치 등을 설정
neptune.trail = curve(color =neptune.color)
neptune.velocity = vector(0,0,23)
#해왕성의 속도 설정

pluto = sphere (pos = vec(20534.968,0,0), radius = 75, texture = textures.wood, color = color.orange)
#해왕성의 반지름, 색깔, 질량, 위치 등을 설정
pluto.trail = curve(color = pluto.color)
pluto.velocity = vector(0,0,.01)
#천왕성의 속도 설정
G = -6.7*10**-4

m_sun = 2*10**10
m_mercury = 3.29*10**3
m_venus = 4.87*10**4
m_earth = 6.0*10**4
m_moon = 7.35*10**2
m_mars = 6.39*10**3
m_jupiter = 1.90*10**7
m_saturn = 5.68*10**6
m_uranus = 8.68*10**5
m_neptune = 1.02*10**6
m_pluto = 1.31*10**2
m_spaceship =  7.0*10**5
#행성 별 질량 측정
mercury_RealRatio = 1.600
venus_RealRatio = 1.177
earth_RealRatio = 1.000
mars_RealRatio = 0.805
jupiter_RealRatio = 0.437
saturn_RealRatio = 0.324
uranus_RealRatio = 0.228
neptune_RealRatio = 0.182
pluto_RealRatio = 0.158
#행성 별 실제 공전 속도 측정
t = 0
deltat = .01
time_interval = 0.05
time_interval_int = int(time_interval/deltat)

graphpos = gdisplay (x=600, y=0, xtitle = "Time", ytitle="Position", width = 600, height=400, title="Position vs.Time of Earth")
earthposx = gcurve(gdisplay=graphpos, color = color.blue)

graphv = gdisplay(x=600, y=500, xtitle = "Time", ytitle="Velocity", width = 600, height = 400, foreground = color.black, background = color.white, title= "Velocity vs. Time of Earth")
earthvelocity = gcurve(gdisplay = graphv, color = color.blue)
#그래프의 초기 설정
tlist = []
vlist = []
graphGPE = gdisplay (x=800, y=500, xtitle = "Position", ytitle ="Gravitational Potential Energy", width = 600, height = 400, title = "GPE vs. Position of Earth to Sun")
earthGPE = gcurve(gdisplay = graphGPE, color = color.green)

graphSpeedRatios = gdisplay (x=600, y=500, xtitle = "Time", ytitle="Speed Ratio", width = 600, height = 400, title = "Planet Speed Ratios to Earth vs. Time")
mercuryRatio = gcurve(gdisplay = graphSpeedRatios, color = color.red)
mercuryRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.red)

venusRatio = gcurve(gdisplay = graphSpeedRatios, color = color.orange)
venusRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.orange)

earthRatio = gcurve(gdisplay = graphSpeedRatios, color = color.yellow)
earthRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.yellow)

marsRatio = gcurve(gdisplay = graphSpeedRatios, color = color.green)
marsRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.green)

jupiterRatio = gcurve(gdisplay = graphSpeedRatios, color = color.cyan)
jupiterRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.cyan)

saturnRatio = gcurve(gdisplay = graphSpeedRatios, color = color.blue)
saturnRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.blue)

uranusRatio = gcurve(gdisplay = graphSpeedRatios, color = color.magenta)
uranusRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.magenta)

neptuneRatio = gcurve(gdisplay = graphSpeedRatios, color = color.red)
neptuneRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.red)

plutoRatio = gcurve(gdisplay = graphSpeedRatios, color = color.orange)
plutoRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.orange)

while True :
    rate(10000)
    
    mercury.trail.append(pos=mercury.pos)
    distanceMercury = mag(mercury.pos)
    UnitVectorMercury = (mercury.pos - sun.pos)/distanceMercury
    FgravMercury = (G*m_sun*m_mercury*UnitVectorMercury)/distanceMercury**2
    mercury.velocity = mercury.velocity +(FgravMercury/m_mercury)*deltat
    mercury.pos = mercury.pos + mercury.velocity*deltat
    mercury.rotate(angle = radians(10), axis = vec(0,1,0))
    if distanceMercury <= sun.radius : break
    mercury_Ratio = mag(mercury.velocity)/mag(earth.velocity)
     
    venus.trail.append(pos=venus.pos)
    distanceVenus = mag(venus.pos)
    UnitVectorVenus = (venus.pos - sun.pos)/distanceVenus
    FgravVenus = (G*m_sun*m_venus*UnitVectorVenus)/distanceVenus**2
    venus.velocity = venus.velocity + (FgravVenus/m_venus)*deltat
    venus.pos = venus.pos + venus.velocity*deltat
    venus.rotate(angle = radians(20), axis = vec(0,1,0))
    if distanceVenus <= sun.radius : break
    venus_Ratio = mag(venus.velocity)/mag(earth.velocity)
    
    earth.trail.append(pos=earth.pos)
    distanceEarth = mag(earth.pos)
    UnitVectorEarth = (earth.pos - sun.pos)/distanceEarth
    FgravEarth = (G*m_sun*m_earth*UnitVectorEarth)/distanceEarth**2
    earth.velocity = earth.velocity + (FgravEarth/m_earth)*deltat
    earth.pos = earth.pos + earth.velocity*deltat
    earth.rotate(angle = radians(30), axis = vec(0,1,0))
    earth_GPE = (G*m_sun*m_earth)/distanceEarth
    if distanceEarth <= sun.radius : break
    earth_Ratio = mag(earth.velocity)/mag(earth.velocity)

    mars.trail.append(pos=mars.pos)
    distanceMars = mag(mars.pos)
    UnitVectorMars = (mars.pos - sun.pos)/distanceMars
    FgravMars = (G*m_sun*m_mars*UnitVectorMars)/distanceMars**2
    mars.velocity = mars.velocity +(FgravMars/m_mars)*deltat
    mars.pos = mars.pos + mars.velocity*deltat
    mars.rotate(angle = radians(15), axis = vec(0,1,0))
    if distanceMars <= sun.radius : break
    mars_Ratio = mag(mars.velocity)/mag(earth.velocity)
    
    jupiter.trail.append(pos=jupiter.pos)
    distanceJupiter = mag(jupiter.pos)
    UnitVectorJupiter = (jupiter.pos - sun.pos)/distanceJupiter
    FgravJupiter = (G*m_sun*m_jupiter*UnitVectorJupiter)/distanceJupiter**2
    jupiter.velocity = jupiter.velocity +(FgravJupiter/m_jupiter)*deltat
    jupiter.pos = jupiter.pos + jupiter.velocity*deltat
    jupiter.rotate(angle = radians(15), axis = vec(0,1,0))
    if distanceJupiter <= sun.radius : break
    jupiter_Ratio = mag(jupiter.velocity)/mag(earth.velocity)
    
    saturn.trail.append(pos=saturn.pos)
    distanceSaturn = mag(saturn.pos)
    UnitVectorSaturn = (saturn.pos - sun.pos)/distanceSaturn
    FgravSaturn = (G*m_sun*m_saturn*UnitVectorSaturn)/distanceSaturn**2
    saturn.velocity = saturn.velocity +(FgravSaturn/m_saturn)*deltat
    saturn.pos = saturn.pos + saturn.velocity*deltat
    saturn.rotate(angle = radians(15), axis = vec(0,1,0))
    if distanceSaturn <= sun.radius : break
    saturn_Ratio = mag(saturn.velocity)/mag(earth.velocity)
    
    uranus.trail.append(pos=uranus.pos)
    distanceUranus = mag(uranus.pos)
    UnitVectorUranus = (uranus.pos - sun.pos)/distanceUranus
    FgravUranus = (G*m_sun*m_uranus*UnitVectorUranus)/distanceUranus**2
    uranus.velocity = uranus.velocity +(FgravUranus/m_uranus)*deltat
    uranus.pos = uranus.pos + uranus.velocity*deltat
    uranus.rotate(angle = radians(15), axis = vec(0,1,0))
    if distanceUranus <= sun.radius : break
    uranus_Ratio = mag(uranus.velocity)/mag(earth.velocity)
    
    neptune.trail.append(pos=neptune.pos)
    distanceNeptune = mag(neptune.pos)
    UnitVectorNeptune = (neptune.pos - sun.pos)/distanceNeptune
    FgravNeptune = (G*m_sun*m_neptune*UnitVectorNeptune)/distanceNeptune**2
    neptune.velocity = neptune.velocity +(FgravNeptune/m_neptune)*deltat
    neptune.pos = neptune.pos + neptune.velocity*deltat
    neptune.rotate(angle = radians(15), axis = vec(0,1,0))
    if distanceNeptune <= sun.radius : break
    neptune_Ratio = mag(neptune.velocity)/mag(earth.velocity) 
    
    pluto.trail.append(pos=pluto.pos)
    distancePluto = mag(pluto.pos)
    UnitVectorPluto  = (pluto.pos - sun.pos)/distancePluto 
    FgravPluto  = (G*m_sun*m_pluto*UnitVectorPluto )/distancePluto **2
    pluto.velocity = pluto.velocity +(FgravPluto /m_pluto)*deltat
    pluto.pos = pluto.pos + pluto.velocity*deltat
    pluto.rotate(angle = radians(15), axis = vec(0,1,0))
    if distancePluto  <= sun.radius : break
    pluto_Ratio = mag(pluto.velocity)/mag(earth.velocity) 
    
    earthposx.plot(pos=(t,earth.pos.x))
    earthvelocity.plot(pos=(t,earth.velocity.x))
    earthGPE.plot(pos=(earth.pos.x,earth_GPE))
    
    
    vlist.append(earth.velocity.x)
    tlist.append(t)
    t = t + deltat

    mercuryRatio.plot(pos=(t,mercury_Ratio))
    mercuryRealRatio.plot(pos=(t,mercury_RealRatio))
    
    venusRatio.plot(pos=(t,venus_Ratio))
    venusRealRatio.plot(pos=(t,venus_RealRatio))
    
    earthRatio.plot(pos=(t,earth_Ratio))
    earthRealRatio.plot(pos=(t,earth_RealRatio))
    
    marsRatio.plot(pos=(t,mars_Ratio))
    marsRealRatio.plot(pos=(t,mars_RealRatio))
    
    jupiterRatio.plot(pos=(t,jupiter_Ratio))
    jupiterRealRatio.plot(pos=(t,jupiter_RealRatio))
    
    saturnRatio.plot(pos=(t,saturn_Ratio))
    saturnRealRatio.plot(pos=(t,saturn_RealRatio))
    
    uranusRatio.plot(pos=(t,uranus_Ratio))
    uranusRealRatio.plot(pos=(t,uranus_RealRatio))
    
    neptuneRatio.plot(pos=(t,neptune_Ratio))
    neptuneRealRatio.plot(pos=(t,neptune_RealRatio))
    
    plutoRatio.plot(pos=(t,pluto_Ratio))
    plutoRealRatio.plot(pos=(t,pluto_RealRatio))
    
    t = t + deltat)
5)내가 기여한 내용에 대한 설명
주석을 첨부할 것이다.
6)내가 기여한 내용의 반영 여부 : (O,X 중 선택해주세요)

 [프로젝트 2 : 탄소 순환을 이용한 지구온난화 분석 및 '인류 멸망 주식회사']
1)연구소 이름 : 연구소 이름을 까먹은 연구팀의 연구소(진짜 까먹었어요 죄송합니다)
2)연구소가 해결하려는 문제 : (인류에 대한 증오심을 품고 있는 반상어 씨)
3)연구소의 깃헙 링크 : (https://github.com/Usernam02/2508-2510)
4)내가 기여한 내용
class Queue :
    def __init__(self) :
        self.items = []
    def enqueue(self,item) :
        self.items.insert(0,item) 
    def dequeue(self) :
        return self.items.pop()
    def isEmpty(self) :
        return self.items == []
    def size(self) :
        return len(self.items)
g = Queue()
k = Queue()
b = Queue()
s = Queue()
for i in range(0,100):
    g.enqueue(1)
    k.enqueue(1)
    b.enqueue(1)
    s.enqueue(1)
a1 = g.size() // 3
a2 = k.size() // 4
a3 = b.size() // 2
a4 = s.size() // 5
for i in range(a1) :
    g.dequeue()
for i in range(a2) :
    k.dequeue()
for i in range(a3) :
    b.dequeue()
for i in range(a4) :
    s.dequeue()
for i in range(a2) :
    g.enqueue(1)
for i in range(a3) :
    k.enqueue(1)
for i in range(a4) :
    b.enqueue(1)
for i in range(a1) :
    s.enqueue(1)
print(g.size())
print(k.size())
print(b.size())
print(s.size())



q=True                                       #f= 수확량
wf=input('뭐 먹을래? 감자 보리 밀 쌀 인공 음식     ')
if wf=='감자' :
    f=292
elif wf=='보리' :
    f=176
elif wf=='밀' :
    f=248
elif wf=='쌀' :
    f=264
elif wf=='채소' :
    f=2
elif wf=='빵' :
    print('빵이 없으면 캐이크를 먹어-말이 안통하네트')
    q=False
elif wf=='인공 음식' :
    f=10000000
else :
    print('그런 거 없다 반동분자야')
    q=False
a=10000
g=10000
h=70
at=[]
gt=[]
wt=[]
ht=[]
w=1000
y=2019
while q :
    b=int(input('편안함'))
    for i in range(1,41):
        at.append(a)
        gt.append(g)
        wt.append(w)
        ht.append(h)
        y=y+1                         #해는 1년씩 늘어남
        nw=int(a*0.1)
        bh=int(b*h)
        bh1=int(bh*0.4)
        bh2=int(bh*0.1)
        f1=int(f*0.1)
        a=a+w-nw+h+bh2-f1            #1년 후 이산화탄소의 양
        g=g-bh+f-h                   #1년 후 화석 연료의 양
        w=nw
        dh=int(0.08*h)
        nh=int(0.02*bh)
        if a<3000 :                     #이산화탄소 농도가 너무 낮으면 호흡이 안되서 농사가 망함
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='')
            print('농사가 망했습니다 you die')
            at.append(a)
            q=False
            break
        elif f-h<0 :                #인구에 비해 수확량이 적으면 정부에 반기를 든 분노한 시민들이 폭동을 일으킵니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='')
            print('수확량이 부족합니다 폭동이 일어났습니다 you die')
            q=False
            break
        elif g<0 :                  #화석 연료가 없어서 너는 굶어 죽습니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print('화석 연료가 다 떨어졌습니다 가장 현실에 가깝습니다 you die')
            gt.append(g)
            q=False
            break
        elif a>30000:               #이산화탄소 농도가 너무 높으면 질식사합니다
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print('숨이 막혀 오는 것이 느껴집니다 you die')
            at.append(a)
            q=False
            break
        elif f-h>500 :             #수확량이 인구에 비해 너무 많으면 넘쳐나는 음식물 쓰레기를 주체할 수 없게 됩니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print('음식물 쓰레기가 너무 많습니다 you die')
            q=False
            break
        else :
            h=h-dh+nh
    import matplotlib.pyplot as plt
    plt.figure(figsize = (5,3), dpi = 300) # 그래프 크기 및 해상도 조절

    plt.rc('font',family='Malgun Gothic') # 한글 폰트설정
    plt.plot(at, '.')
    plt.title('a') # 제목 넣기

    plt.xlim(0,len(at)+1) # x축 값 범위
    plt.ylim(1000,21000) # y축 값 범위

    plt.xlabel('x축') # x축 레이블
    plt.ylabel('y축') # y축 레이블

    plt.savefig('data.png') # 파일 저장

    plt.show() # 그래프 보여주기
    print(at)
    print(gt)
    print(wt)
    print(ht)
5)내가 기여한 내용에 대한 설명

6)내가 기여한 내용의 반영 여부 : (O,X 중 선택해주세요)

 [프로젝트 3 : 길 찾기 문제 해결 프로그램의 코드 오류 수정]
1)연구소 이름 : (공유 파일에서 복붙하세요)
2)연구소가 해결하려는 문제 : (공유 파일에서 복붙하세요)
3)연구소의 깃헙 링크 : (공유 파일에서 복붙하세요)
4)내가 기여한 내용
(코드, 주석, 문서화 등 내가 기여한 내용을 복붙해주세요)
5)내가 기여한 내용에 대한 설명
(자신이 어떤 기여를 한 것인지 설명해주세요)
6)내가 기여한 내용의 반영 여부 : (O,X 중 선택해주세요)
